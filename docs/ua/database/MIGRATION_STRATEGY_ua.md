# Стратегія Міграції Даних
## Система Моніторингу та Відстеження Нагород

> **Результат Фази 9**: Архітектура Даних та Проєктування Бази Даних  
> **Версія Документа**: 1.0  
> **Останнє Оновлення**: Грудень 2025  
> **Автор**: Стефан Костик  
> **Інструмент Міграції**: Flyway  
> **Класифікація**: Внутрішній

---

## Резюме

Цей документ визначає комплексну стратегію міграції даних для Системи Моніторингу та Відстеження Нагород. Він охоплює версіонування схеми з Flyway, політики архівування даних, процедури резервного копіювання та відновлення, а також підходи до розгортання без простою. Стратегія забезпечує безпечну, повторювану та аудитовну еволюцію бази даних протягом життєвого циклу застосунку.

### Ключові Компоненти Стратегії

| **Компонент** | **Інструмент/Підхід** | **Призначення** |
|---------------|----------------------|-----------------|
| Версіонування Схеми | Flyway Community | Версіоновані, повторювані міграції |
| Архівування Даних | Заплановані Завдання + Політики | Відповідність GDPR, продуктивність |
| Стратегія Бекапу | PostgreSQL pg_dump + WAL | Відновлення на момент часу |
| Процедури Відновлення | Документовані runbooks | Безперервність бізнесу |
| Без Простою | Blue-green + зворотна сумісність | Безперервне розгортання |

---

## 1. Версіонування Схеми з Flyway

### 1.1 Стратегія Конфігурації Flyway

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        АРХІТЕКТУРА МІГРАЦІЙ FLYWAY                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Типи Файлів Міграцій:                                                      │
│  ─────────────────────                                                       │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  V (Версіоновані Міграції)                                          │    │
│  │  ─────────────────────────                                           │    │
│  │  • Виконуються один раз, по порядку                                  │    │
│  │  • Зміни схеми, міграції даних                                       │    │
│  │  • Патерн: V{version}__{description}.sql                             │    │
│  │  • Приклад: V001__create_users_table.sql                             │    │
│  │  • Checksum валідується (помилка якщо змінено)                       │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  R (Повторювані Міграції)                                           │    │
│  │  ─────────────────────────                                           │    │
│  │  • Виконуються коли змінюється checksum                              │    │
│  │  • Views, functions, seed дані                                       │    │
│  │  • Патерн: R__{description}.sql                                      │    │
│  │  • Приклад: R__seed_award_categories.sql                             │    │
│  │  • Повинні бути ідемпотентними (CREATE OR REPLACE)                   │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  U (Undo Міграції) - Тільки Enterprise                              │    │
│  │  ───────────────────────────────────                                 │    │
│  │  • Не використовується в Community Edition                           │    │
│  │  • Ручні rollback скрипти підтримуються окремо                       │    │
│  │  • Патерн: U{version}__{description}.sql                             │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.2 Структура Директорії Міграцій

```
src/main/resources/
└── db/
    └── migration/
        ├── V001__create_users_table.sql
        ├── V002__create_organizations_table.sql
        ├── V003__create_user_roles_table.sql
        ├── V004__create_award_categories_table.sql
        ├── V005__create_awards_table.sql
        ├── V006__create_documents_table.sql
        ├── V007__create_award_requests_table.sql
        ├── V008__create_review_decisions_table.sql
        ├── V009__create_audit_logs_table.sql
        ├── V010__create_consent_records_table.sql
        ├── V011__create_notifications_tables.sql
        ├── V012__create_indexes.sql
        ├── V013__create_audit_triggers.sql
        ├── R__create_views.sql
        ├── R__create_functions.sql
        ├── R__seed_organizations.sql
        └── R__seed_award_categories.sql
```

### 1.3 Конвенція Нумерації Версій

| **Формат Версії** | **Приклад** | **Випадок Використання** |
|-------------------|-------------|--------------------------|
| `V{NNN}__` | `V001__` | Великі зміни схеми (початкові, нові таблиці) |
| `V{NNN}.{N}__` | `V001.1__` | Незначні доповнення до існуючої міграції |
| `V{YYYYMMDD}.{N}__` | `V20251215.1__` | Версіонування на основі дати (альтернатива) |

**Рекомендовано**: Використовувати послідовну тризначну нумерацію (`V001`, `V002`, ...) для ясності та простоти.

### 1.4 Конфігурація Інтеграції Spring Boot

```yaml
# application.yml - Конфігурація Flyway (для довідки розробки)
spring:
  flyway:
    enabled: true
    locations: classpath:db/migration
    baseline-on-migrate: true
    baseline-version: 0
    validate-on-migrate: true
    out-of-order: false
    clean-disabled: true  # КРИТИЧНО: Запобігти випадковій втраті даних
    
    # PostgreSQL-специфічні налаштування
    schemas:
      - public
    default-schema: public
    
    # Placeholders для значень специфічних для середовища
    placeholders:
      schema_name: public
      
# Перевизначення для конкретного середовища
---
spring:
  config:
    activate:
      on-profile: production
  flyway:
    baseline-on-migrate: false  # Ніколи не baseline в продакшні
    validate-on-migrate: true
```

### 1.5 Шаблони Файлів Міграцій

#### Шаблон: Версіонована Міграція (Зміна Схеми)

```sql
-- V{version}__{description}.sql
-- Опис: {Короткий опис змін}
-- Автор: Стефан Костик
-- Дата: {YYYY-MM-DD}
-- Тікет: {Посилання на JIRA/Issue якщо є}

-- Попередні перевірки
DO $$
BEGIN
    -- Перевірити передумови якщо потрібно
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'required_table') THEN
        RAISE EXCEPTION 'Передумова не виконана: required_table не існує';
    END IF;
END $$;

-- Міграція
CREATE TABLE new_table (
    id BIGSERIAL PRIMARY KEY,
    -- колонки...
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    version BIGINT NOT NULL DEFAULT 1
);

-- Індекси
CREATE INDEX idx_new_table_column ON new_table(column);

-- Коментарі
COMMENT ON TABLE new_table IS 'Опис призначення таблиці';
COMMENT ON COLUMN new_table.column IS 'Опис колонки';

-- Надати права (якщо потрібно)
-- GRANT SELECT, INSERT, UPDATE, DELETE ON new_table TO app_user;
```

#### Шаблон: Повторювана Міграція (Seed Дані)

```sql
-- R__seed_{entity}.sql
-- Опис: Seed дані для {entity} - Ідемпотентний
-- Автор: Стефан Костик
-- Примітка: Ця міграція перезапускається кожного разу коли файл змінюється

-- Підхід очистки та повторного заповнення (для довідкових даних)
TRUNCATE TABLE reference_table CASCADE;

INSERT INTO reference_table (id, name, name_uk, description) VALUES
    (1, 'Value 1', 'Значення 1', 'Опис 1'),
    (2, 'Value 2', 'Значення 2', 'Опис 2');

-- Альтернатива: Підхід Upsert (для даних які можуть модифікуватися)
INSERT INTO reference_table (id, name, name_uk, description)
VALUES (1, 'Value 1', 'Значення 1', 'Опис 1')
ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    name_uk = EXCLUDED.name_uk,
    description = EXCLUDED.description;

-- Скинути sequence до max id
SELECT setval('reference_table_id_seq', COALESCE((SELECT MAX(id) FROM reference_table), 1));
```

---

## 2. Стратегія Виконання Міграцій

### 2.1 Підхід Специфічний для Середовища

| **Середовище** | **Виконання** | **Валідація** | **Rollback** |
|----------------|---------------|---------------|--------------|
| **Розробка** | Авто при запуску | М'яка | Drop та перестворення |
| **Тестування** | Авто при запуску | Сувора | Свіжа БД на кожен тест |
| **Staging** | Ручне затвердження | Сувора + dry-run | Ручні скрипти |
| **Продакшн** | Ручне затвердження | Сувора + dry-run | Ручні скрипти + бекап |

### 2.2 Робочий Процес Виконання Міграцій

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      РОБОЧИЙ ПРОЦЕС ВИКОНАННЯ МІГРАЦІЙ                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  РОЗРОБКА                                                                   │
│  ───────────                                                                 │
│  1. Розробник створює файл міграції                                         │
│  2. Застосунок запускається → Flyway авто-мігрує                            │
│  3. Тестування локально → Коміт в гілку                                     │
│                                                                              │
│  CI/CD PIPELINE                                                              │
│  ─────────────                                                               │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐  │
│  │   Build     │───►│  Validate   │───►│   Test      │───►│   Package   │  │
│  │   App       │    │  Migrations │    │  Database   │    │   Artifact  │  │
│  └─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘  │
│                            │                  │                             │
│                            ▼                  ▼                             │
│                     ┌─────────────┐    ┌─────────────┐                     │
│                     │ flyway      │    │ testcontainers│                   │
│                     │ validate    │    │ PostgreSQL   │                    │
│                     └─────────────┘    └─────────────┘                     │
│                                                                              │
│  DEPLOYMENT STAGING                                                          │
│  ─────────────────                                                           │
│  1. Створити бекап бази даних                                               │
│  2. Запустити: flyway info (перевірити очікуючі міграції)                   │
│  3. Запустити: flyway validate (перевірити checksums)                       │
│  4. Запустити: flyway migrate (застосувати зміни)                           │
│  5. Запустити інтеграційні тести                                            │
│  6. Ручна QA верифікація                                                    │
│                                                                              │
│  DEPLOYMENT ПРОДАКШН                                                         │
│  ────────────────────                                                        │
│  1. Створити бекап бази даних (повний + WAL)                                │
│  2. Повідомити зацікавлених про вікно розгортання                           │
│  3. Запустити: flyway info (переглянути очікуючі)                           │
│  4. Запустити: flyway validate (верифікація checksum)                       │
│  5. Запустити: flyway migrate -dryRun (попередній перегляд)                 │
│  6. ЗАТВЕРДЖЕННЯ: Перевірка DevOps/DBA                                      │
│  7. Запустити: flyway migrate (застосувати)                                 │
│  8. Перевірити стан здоров'я застосунку                                     │
│  9. Моніторинг 15 хвилин                                                    │
│  10. Оновити журнал розгортання                                             │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.3 Правила Зворотної Сумісності

Для забезпечення розгортань без простою, всі міграції повинні бути зворотно сумісними:

| **Тип Зміни** | **Дозволено** | **Стратегія Міграції** |
|---------------|---------------|------------------------|
| Додати таблицю | ✅ Так | Одна міграція |
| Додати nullable колонку | ✅ Так | Одна міграція |
| Додати колонку з default | ✅ Так | Одна міграція |
| Додати індекс | ✅ Так | `CREATE INDEX CONCURRENTLY` |
| Перейменувати колонку | ⚠️ Обережно | Багатофазно (додати нову, мігрувати, видалити стару) |
| Перейменувати таблицю | ⚠️ Обережно | Багатофазно з views |
| Видалити колонку | ⚠️ Обережно | Спочатку код (перестати використовувати), потім drop |
| Видалити таблицю | ⚠️ Обережно | Спочатку код (перестати використовувати), потім drop |
| Змінити тип колонки | ⚠️ Обережно | Багатофазна міграція |
| Додати NOT NULL | ⚠️ Обережно | Спочатку заповнити дані |

### 2.4 Приклад Багатофазної Міграції

```sql
-- Фаза 1: Додати нову колонку (V015__add_user_display_name_phase1.sql)
-- Deploy: Застосунок ігнорує нову колонку
ALTER TABLE users ADD COLUMN display_name VARCHAR(255);

-- Фаза 2: Заповнити дані (V016__backfill_display_name_phase2.sql)
-- Deploy: Застосунок може читати нову колонку
UPDATE users SET display_name = first_name || ' ' || last_name 
WHERE display_name IS NULL;

-- Фаза 3: Зробити обов'язковою (V017__require_display_name_phase3.sql)
-- Deploy: Застосунок використовує нову колонку
ALTER TABLE users ALTER COLUMN display_name SET NOT NULL;
ALTER TABLE users ALTER COLUMN display_name SET DEFAULT '';

-- Фаза 4: Видалити старі колонки (V018__remove_old_name_columns_phase4.sql)
-- Deploy: Застосунок більше не посилається на старі колонки (розгорнуто раніше)
ALTER TABLE users DROP COLUMN first_name;
ALTER TABLE users DROP COLUMN last_name;
```

---

## 3. Стратегія Архівування Даних

### 3.1 Матриця Політик Архівування

| **Сутність** | **Період Зберігання** | **Тригер Архівування** | **Стратегія Архівування** |
|--------------|----------------------|------------------------|---------------------------|
| `audit_logs` | 7 років | Вік > 7 років | Drop партиції або холодне сховище |
| `notifications` | 1 рік | Вік > 1 рік | Видалити або архівувати в S3 |
| `awards` (статус ARCHIVED) | Постійно | Ніколи | Залишити в головній таблиці |
| `documents` (осиротілі) | 90 днів | Немає батьківського посилання | Видалити файл + метадані |
| `consent_records` | 7 років від відкликання | Вік від `withdrawn_at` | Архівувати в холодне сховище |
| `users` (DELETED) | 30 днів grace + 7 років | Запит на видалення | Анонімізувати + архівувати |

### 3.2 Стратегія Реалізації Архівування

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        АРХІТЕКТУРА АРХІВУВАННЯ ДАНИХ                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  HOT ДАНІ (PostgreSQL)           WARM ДАНІ (Archive DB)    COLD ДАНІ (S3)  │
│  ─────────────────────           ─────────────────────     ──────────────   │
│                                                                              │
│  ┌─────────────────┐            ┌─────────────────┐     ┌─────────────────┐│
│  │ Поточний Рік    │            │ Роки 2-7        │     │ Після 7 років   ││
│  │ audit_logs      │───────────►│ audit_logs_arch │────►│ audit_logs.parquet│
│  │ (Партиціоновані)│  Щомісяця  │ (Read-only)     │ Щороку │ (Стиснуті)     ││
│  └─────────────────┘  Архів     └─────────────────┘ Експорт└─────────────────┘│
│                                                                              │
│  ┌─────────────────┐                                                        │
│  │ notifications   │─────────────────────────────────────►┌─────────────┐   │
│  │ (< 1 рік)       │  Після 1 року: DELETE               │ /dev/null   │   │
│  └─────────────────┘  (Немає бізнес-цінності)            └─────────────┘   │
│                                                                              │
│  ┌─────────────────┐            ┌─────────────────┐                         │
│  │ consent_records │───────────►│ consent_archive │                         │
│  │ (Активні)       │  При       │ (Тільки         │                         │
│  │                 │  Відкликанні│  відкликані)   │                         │
│  └─────────────────┘            └─────────────────┘                         │
│                                                                              │
│  РОЗКЛАД ЗАВДАНЬ АРХІВУВАННЯ                                                │
│  ─────────────────────────────                                               │
│  • Щоденно (2 AM UTC): Очищення сповіщень                                   │
│  • Щотижня (Неділя 3 AM): Очищення осиротілих документів                    │
│  • Щомісяця (1-е, 4 AM): Управління партиціями audit log                    │
│  • Щоквартально: Генерація повного звіту архівування                        │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.3 Управління Партиціями для Audit Logs

```sql
-- Стратегія управління партиціями (документовано для реалізації розробки)

-- Створити батьківську таблицю з партиціонуванням
CREATE TABLE audit_logs (
    log_id BIGSERIAL,
    user_id BIGINT,
    action_type VARCHAR(50) NOT NULL,
    entity_type VARCHAR(50) NOT NULL,
    entity_id BIGINT,
    old_values JSONB,
    new_values JSONB,
    ip_address INET,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    PRIMARY KEY (log_id, created_at)
) PARTITION BY RANGE (created_at);

-- Щомісячне створення партицій (автоматизовано через заплановане завдання)
-- CREATE TABLE audit_logs_2025_01 PARTITION OF audit_logs
--     FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

-- Функція обслуговування партицій
CREATE OR REPLACE FUNCTION fn_create_audit_partition()
RETURNS void AS $$
DECLARE
    partition_date DATE := DATE_TRUNC('month', CURRENT_DATE + INTERVAL '1 month');
    partition_name TEXT := 'audit_logs_' || TO_CHAR(partition_date, 'YYYY_MM');
    start_date TEXT := TO_CHAR(partition_date, 'YYYY-MM-DD');
    end_date TEXT := TO_CHAR(partition_date + INTERVAL '1 month', 'YYYY-MM-DD');
BEGIN
    EXECUTE format(
        'CREATE TABLE IF NOT EXISTS %I PARTITION OF audit_logs FOR VALUES FROM (%L) TO (%L)',
        partition_name, start_date, end_date
    );
END;
$$ LANGUAGE plpgsql;

-- Архівувати старі партиції (перемістити до схеми архіву або видалити)
-- DROP TABLE audit_logs_2018_01;  -- Після експорту даних в холодне сховище
```

### 3.4 Процедури Видалення Даних GDPR

```sql
-- Процедура видалення користувача (30-денний grace період + анонімізація)
-- Це документація; фактична реалізація через сервіс застосунку

-- Крок 1: Позначити для видалення (негайно)
UPDATE users SET 
    account_status = 'DELETED',
    deletion_requested_at = CURRENT_TIMESTAMP,
    scheduled_deletion_at = CURRENT_TIMESTAMP + INTERVAL '30 days'
WHERE user_id = :user_id;

-- Крок 2: Після grace періоду - Анонімізувати (заплановане завдання)
-- Нагороди зберігаються але анонімізовані (цінність публічного запису)
BEGIN;
    -- Анонімізувати користувача
    UPDATE users SET
        email_address = 'deleted_' || user_id || '@anonymized.local',
        first_name = 'Видалений',
        last_name = 'Користувач',
        password_hash = 'DELETED',
        updated_at = CURRENT_TIMESTAMP
    WHERE user_id = :user_id AND account_status = 'DELETED';
    
    -- Зберегти нагороди але видалити персональне посилання в публічних views
    UPDATE awards SET
        updated_at = CURRENT_TIMESTAMP
    WHERE user_id = :user_id;
    
    -- Архівувати записи згоди
    INSERT INTO consent_archive SELECT * FROM consent_records WHERE user_id = :user_id;
    DELETE FROM consent_records WHERE user_id = :user_id;
    
    -- Видалити налаштування сповіщень
    DELETE FROM notification_preferences WHERE user_id = :user_id;
    
    -- Видалити сповіщення (немає цінності зберігання)
    DELETE FROM notifications WHERE user_id = :user_id;
COMMIT;
```

---

## 4. Стратегія Резервного Копіювання та Відновлення

### 4.1 Огляд Стратегії Бекапу

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        ОГЛЯД СТРАТЕГІЇ БЕКАПУ                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ТИПИ БЕКАПІВ                                                               │
│  ────────────                                                                │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  ПОВНИЙ БЕКАП (pg_dump)                                             │    │
│  │  ─────────────────────                                               │    │
│  │  • Повний snapshot бази даних                                        │    │
│  │  • Частота: Щоденно о 2 AM UTC                                       │    │
│  │  • Зберігання: 30 днів                                               │    │
│  │  • Storage: S3 з cross-region реплікацією                            │    │
│  │  • Стиснення: gzip (типово 5:1 ratio)                                │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  БЕЗПЕРЕРВНЕ WAL АРХІВУВАННЯ                                        │    │
│  │  ──────────────────────                                              │    │
│  │  • Write-Ahead Log streaming                                         │    │
│  │  • Частота: Безперервно (кожні 16MB або 5 хвилин)                    │    │
│  │  • Зберігання: 7 днів                                                │    │
│  │  • Забезпечує Point-in-Time Recovery (PITR)                          │    │
│  │  • Storage: S3 з lifecycle policies                                  │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  ЛОГІЧНИЙ БЕКАП (На рівні таблиць)                                  │    │
│  │  ────────────────────────────                                        │    │
│  │  • Тільки критичні таблиці: users, awards, documents                 │    │
│  │  • Частота: Щогодини протягом робочих годин                          │    │
│  │  • Зберігання: 7 днів                                                │    │
│  │  • Формат: CSV для легкого відновлення                               │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ВЕРИФІКАЦІЯ БЕКАПІВ                                                        │
│  ───────────────────                                                         │
│  • Щоденно: Автоматизована перевірка цілісності бекапу                      │
│  • Щотижня: Тест відновлення на staging                                     │
│  • Щомісяця: Повне навчання disaster recovery                               │
│  • Щоквартально: Cross-region тест відновлення                              │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 Recovery Point Objective (RPO) та Recovery Time Objective (RTO)

| **Сценарій** | **RPO** | **RTO** | **Метод Відновлення** |
|--------------|---------|---------|----------------------|
| **Збій Обладнання** | 0 (streaming реплікація) | 5 хвилин | Failover на репліку |
| **Пошкодження Даних** | 5 хвилин (WAL) | 30 хвилин | PITR до пошкодження |
| **Випадкове Видалення** | 5 хвилин (WAL) | 1 година | PITR до видалення |
| **Регіональна Катастрофа** | 1 година (cross-region) | 4 години | Cross-region відновлення |
| **Повна Втрата** | 24 години (щоденний бекап) | 8 годин | Повне відновлення з бекапу |

### 4.3 Довідник Команд Бекапу

```bash
# Повний бекап бази даних (документація для операцій)
pg_dump -Fc -Z9 -f backup_$(date +%Y%m%d_%H%M%S).dump \
    -h $DB_HOST -U $DB_USER -d award_monitoring

# Бекап тільки схеми (для тестування міграцій)
pg_dump --schema-only -f schema_$(date +%Y%m%d).sql \
    -h $DB_HOST -U $DB_USER -d award_monitoring

# Бекап конкретних таблиць
pg_dump -Fc -t users -t awards -t documents \
    -f critical_tables_$(date +%Y%m%d_%H%M%S).dump \
    -h $DB_HOST -U $DB_USER -d award_monitoring

# Конфігурація WAL архівування (postgresql.conf)
# archive_mode = on
# archive_command = 'aws s3 cp %p s3://bucket/wal/%f'
# archive_timeout = 300  # 5 хвилин

# Відновлення з повного бекапу
pg_restore -d award_monitoring -h $DB_HOST -U $DB_USER backup.dump

# Point-in-Time Recovery (PITR)
# 1. Зупинити PostgreSQL
# 2. Відновити базовий бекап
# 3. Налаштувати recovery.conf:
#    restore_command = 'aws s3 cp s3://bucket/wal/%f %p'
#    recovery_target_time = '2025-12-15 14:30:00'
# 4. Запустити PostgreSQL (режим відновлення)
# 5. Промотувати до primary коли готово
```

### 4.4 Процедури Відновлення

#### Процедура 1: Відновлення Однієї Таблиці

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  ПРОЦЕДУРА: Відновлення Однієї Таблиці з Бекапу                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Передумови:                                                                │
│  - Доступ до файлів бекапу                                                  │
│  - З'єднання з цільовою базою даних                                         │
│  - Вікно простою (якщо продакшн)                                            │
│                                                                              │
│  Кроки:                                                                      │
│                                                                              │
│  1. ІДЕНТИФІКУВАТИ бекап що містить потрібні дані                           │
│     $ aws s3 ls s3://backup-bucket/daily/ | grep 2025-12-15                │
│                                                                              │
│  2. ЗАВАНТАЖИТИ бекап на локальний/staging                                  │
│     $ aws s3 cp s3://backup-bucket/daily/backup_20251215.dump .            │
│                                                                              │
│  3. СТВОРИТИ тимчасову базу даних для витягу                                │
│     $ createdb temp_restore                                                 │
│     $ pg_restore -d temp_restore backup_20251215.dump                      │
│                                                                              │
│  4. ВИТЯГТИ дані таблиці                                                    │
│     $ pg_dump -t target_table temp_restore > table_data.sql                │
│                                                                              │
│  5. ВИМКНУТИ тригери на цільовій таблиці (продакшн)                         │
│     $ psql -c "ALTER TABLE target_table DISABLE TRIGGER ALL"               │
│                                                                              │
│  6. ВІДНОВИТИ дані в продакшн                                               │
│     $ psql -d production < table_data.sql                                  │
│                                                                              │
│  7. УВІМКНУТИ тригери                                                       │
│     $ psql -c "ALTER TABLE target_table ENABLE TRIGGER ALL"                │
│                                                                              │
│  8. ВЕРИФІКУВАТИ цілісність даних                                           │
│     $ psql -c "SELECT COUNT(*) FROM target_table"                          │
│                                                                              │
│  9. ОЧИСТИТИ                                                                │
│     $ dropdb temp_restore                                                   │
│     $ rm backup_20251215.dump table_data.sql                               │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Процедура 2: Point-in-Time Recovery

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  ПРОЦЕДУРА: Point-in-Time Recovery (PITR)                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Випадок використання: Відновлення до конкретного моменту до пошкодження/втрати│
│                                                                              │
│  Передумови:                                                                │
│  - WAL архівування увімкнено                                                │
│  - Доступний базовий бекап                                                  │
│  - Ідентифікована цільова мітка часу                                        │
│                                                                              │
│  Кроки:                                                                      │
│                                                                              │
│  1. ЗУПИНИТИ з'єднання застосунку                                           │
│     - Зменшити масштаб подів застосунку                                     │
│     - Відкликати права на з'єднання                                         │
│                                                                              │
│  2. ІДЕНТИФІКУВАТИ цільову точку відновлення                                │
│     - Переглянути журнали аудиту для мітки часу інциденту                   │
│     - Ціль: 5 хвилин до інциденту                                           │
│                                                                              │
│  3. ЗУПИНИТИ PostgreSQL                                                     │
│     $ sudo systemctl stop postgresql                                        │
│                                                                              │
│  4. БЕКАПУВАТИ поточну директорію даних (безпека)                           │
│     $ mv /var/lib/postgresql/data /var/lib/postgresql/data_incident        │
│                                                                              │
│  5. ВІДНОВИТИ базовий бекап                                                 │
│     $ tar xzf base_backup.tar.gz -C /var/lib/postgresql/                   │
│                                                                              │
│  6. НАЛАШТУВАТИ відновлення                                                 │
│     # Створити postgresql.auto.conf:                                        │
│     restore_command = 'aws s3 cp s3://bucket/wal/%f %p'                    │
│     recovery_target_time = '2025-12-15 14:25:00+00'                        │
│     recovery_target_action = 'promote'                                      │
│                                                                              │
│  7. СТВОРИТИ файл сигналу відновлення                                       │
│     $ touch /var/lib/postgresql/data/recovery.signal                       │
│                                                                              │
│  8. ЗАПУСТИТИ PostgreSQL                                                    │
│     $ sudo systemctl start postgresql                                       │
│     # PostgreSQL входить в режим відновлення                                │
│     # Відтворює WAL до цільового часу                                       │
│     # Авто-промотується коли завершено                                      │
│                                                                              │
│  9. ВЕРИФІКУВАТИ відновлення                                                │
│     $ psql -c "SELECT pg_is_in_recovery()"  # Має бути 'f'                 │
│     $ psql -c "SELECT COUNT(*) FROM awards"                                │
│                                                                              │
│  10. ВІДНОВИТИ з'єднання застосунку                                         │
│      - Збільшити масштаб подів застосунку                                   │
│      - Відновити права на з'єднання                                         │
│                                                                              │
│  11. ЗАДОКУМЕНТУВАТИ інцидент                                               │
│      - Оновити звіт про інцидент                                            │
│      - Записати дії відновлення                                             │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.5 Моніторинг та Alerting Бекапів

| **Перевірка** | **Частота** | **Поріг Alerting** | **Дія** |
|---------------|-------------|-------------------|---------|
| Завершення завдання бекапу | Щоденно | Відсутній або помилка | Сповістити on-call |
| Розмір файлу бекапу | Щоденно | <50% або >200% від середнього | Дослідити |
| Затримка WAL архіву | Безперервно | >10 хвилин | Сповістити команду |
| Використання сховища бекапів | Щоденно | >80% ємності | Розширити сховище |
| Тест відновлення | Щотижня | Будь-яка помилка | Ескалювати |

---

## 5. Стратегія Розгортання Без Простою

### 5.1 Blue-Green Розгортання Бази Даних

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    BLUE-GREEN РОЗГОРТАННЯ БАЗИ ДАНИХ                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Для великих міграцій що потребують тривалого виконання:                    │
│                                                                              │
│  ┌─────────────────┐        ┌─────────────────┐                             │
│  │    BLUE         │        │    GREEN        │                             │
│  │  (Поточний)     │        │   (Новий)       │                             │
│  ├─────────────────┤        ├─────────────────┤                             │
│  │ PostgreSQL v16  │        │ PostgreSQL v16  │                             │
│  │ Schema v15      │        │ Schema v16      │                             │
│  │ ACTIVE          │        │ STANDBY         │                             │
│  └────────┬────────┘        └────────┬────────┘                             │
│           │                          │                                       │
│           │  Logical Replication     │                                       │
│           └──────────────────────────┘                                       │
│                                                                              │
│  Кроки Розгортання:                                                         │
│                                                                              │
│  1. Створити GREEN базу даних з новою схемою                                │
│  2. Налаштувати logical реплікацію BLUE → GREEN                             │
│  3. Застосувати міграції до GREEN (поки BLUE обслуговує трафік)             │
│  4. Верифікувати узгодженість даних                                         │
│  5. Переключити застосунок на GREEN                                         │
│  6. Моніторити проблеми                                                     │
│  7. Вивести BLUE (або залишити для rollback)                                │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 5.2 Online Зміни Схеми

Для рутинних змін без простою:

| **Операція** | **Online Стратегія** | **Рівень Lock** |
|--------------|---------------------|-----------------|
| Додати колонку (nullable) | Прямий ALTER | ACCESS EXCLUSIVE (коротко) |
| Додати колонку (з default) | Прямий ALTER (PG 11+) | ACCESS EXCLUSIVE (коротко) |
| Додати індекс | `CREATE INDEX CONCURRENTLY` | SHARE UPDATE EXCLUSIVE |
| Видалити індекс | `DROP INDEX CONCURRENTLY` | SHARE UPDATE EXCLUSIVE |
| Додати constraint | Додати як NOT VALID, потім VALIDATE | Мінімальний lock |
| Перейменувати колонку | Уникати; використовувати багатофазну міграцію | - |

```sql
-- Приклад: Додавання індексу без простою
CREATE INDEX CONCURRENTLY idx_awards_new ON awards(new_column);

-- Приклад: Додавання constraint без повного lock
ALTER TABLE awards ADD CONSTRAINT ck_awards_score 
    CHECK (impact_score BETWEEN 0 AND 100) NOT VALID;
    
-- Валідувати окремо (сканує таблицю але не блокує записи)
ALTER TABLE awards VALIDATE CONSTRAINT ck_awards_score;
```

---

## 6. Стратегія Тестування Міграцій

### 6.1 Пре-Продакшн Тестування

| **Тип Тесту** | **Середовище** | **Призначення** | **Автоматизація** |
|---------------|----------------|-----------------|-------------------|
| Валідація схеми | CI pipeline | Перевірка SQL синтаксису | Flyway validate |
| Виконання міграції | Testcontainers | Тест повної міграції | JUnit інтеграція |
| Цілісність даних | Staging | Перевірка узгодженості даних | Кастомні скрипти |
| Вплив на продуктивність | Staging | Вимірювання продуктивності запитів | JMeter/Gatling |
| Верифікація rollback | Staging | Тест rollback скриптів | Ручне |

### 6.2 Інтеграція Testcontainers

```java
// Тестування міграцій з Testcontainers (документація для розробки)
@Testcontainers
class MigrationIntegrationTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:16")
        .withDatabaseName("test_db")
        .withUsername("test")
        .withPassword("test");

    @Test
    void shouldApplyAllMigrationsSuccessfully() {
        Flyway flyway = Flyway.configure()
            .dataSource(postgres.getJdbcUrl(), postgres.getUsername(), postgres.getPassword())
            .locations("classpath:db/migration")
            .load();
        
        flyway.migrate();
        
        // Перевірити очікуваний стан схеми
        assertThat(flyway.info().applied()).hasSizeGreaterThan(0);
        assertThat(flyway.info().pending()).isEmpty();
    }

    @Test
    void shouldHaveValidMigrationChecksums() {
        Flyway flyway = Flyway.configure()
            .dataSource(postgres.getJdbcUrl(), postgres.getUsername(), postgres.getPassword())
            .locations("classpath:db/migration")
            .load();
        
        // Validate не повинен кидати виключення
        assertDoesNotThrow(() -> flyway.validate());
    }
}
```

---

## 7. Стратегія Rollback

### 7.1 Матриця Рішення Rollback

| **Серйозність Проблеми** | **Відповідь** | **Тип Rollback** |
|--------------------------|---------------|------------------|
| Незначна (косметична) | Fix forward | Без rollback |
| Помірна (функціональність) | Оцінити | Schema rollback якщо потрібно |
| Серйозна (ризик втрати даних) | Негайний | Повний rollback + PITR |
| Критична (безпека) | Аварійний | Повний rollback + incident response |

### 7.2 Ручні Скрипти Rollback

Для кожної версіонованої міграції підтримувати відповідний rollback скрипт:

```
src/main/resources/
└── db/
    └── rollback/
        ├── V001__rollback.sql
        ├── V002__rollback.sql
        └── ...
```

```sql
-- Приклад: V005__rollback.sql (Rollback для V005__create_awards_table.sql)
-- УВАГА: Це ВИДАЛИТЬ всі дані awards!
-- Використовувати тільки після підтвердження що втрата даних прийнятна або дані забекаплені

DROP TABLE IF EXISTS awards CASCADE;

-- Повторно увімкнути будь-які зовнішні ключі що були вимкнені
-- Відновити будь-які views що залежали від цієї таблиці
```

### 7.3 Процедура Виконання Rollback

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  ПРОЦЕДУРА: Schema Rollback                                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ⚠️  УВАГА: Rollback може спричинити втрату даних. Переконайтесь що є бекап.│
│                                                                              │
│  1. ЗУПИНИТИ deployment застосунку                                          │
│     $ kubectl rollout pause deployment/award-api                            │
│                                                                              │
│  2. ІДЕНТИФІКУВАТИ цільову версію rollback                                  │
│     $ flyway info                                                           │
│     # Зазначити поточну версію (напр., V016)                                │
│     # Цільова версія (напр., V015)                                          │
│                                                                              │
│  3. СТВОРИТИ бекап перед rollback                                           │
│     $ pg_dump -Fc -f pre_rollback_$(date +%Y%m%d_%H%M%S).dump $DATABASE    │
│                                                                              │
│  4. ВИКОНАТИ rollback скрипт(и)                                             │
│     $ psql -d $DATABASE -f db/rollback/V016__rollback.sql                  │
│                                                                              │
│  5. ОНОВИТИ історію Flyway (позначити як rolled back)                       │
│     $ psql -d $DATABASE -c \                                                │
│       "DELETE FROM flyway_schema_history WHERE version = '016'"             │
│                                                                              │
│  6. ВЕРИФІКУВАТИ стан схеми                                                 │
│     $ flyway info                                                           │
│     $ flyway validate                                                       │
│                                                                              │
│  7. РОЗГОРНУТИ попередню версію застосунку                                  │
│     $ kubectl rollout undo deployment/award-api                             │
│                                                                              │
│  8. ВЕРИФІКУВАТИ стан здоров'я застосунку                                   │
│     $ kubectl get pods                                                      │
│     $ curl -f https://api.example.com/health                               │
│                                                                              │
│  9. ЗАДОКУМЕНТУВАТИ інцидент та rollback                                    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 8. Чеклист Реалізації

### 8.1 Підготовка Фази Розробки

- [ ] Flyway Maven/Gradle плагін налаштований
- [ ] Структура директорії міграцій створена
- [ ] Початкові міграції схеми написані
- [ ] Міграції seed даних підготовлені
- [ ] Testcontainers інтеграційні тести
- [ ] Rollback скрипти для кожної міграції
- [ ] CI pipeline валідація міграцій

### 8.2 Production Readiness

- [ ] Автоматизація бекапів налаштована
- [ ] WAL архівування увімкнено
- [ ] Процедури відновлення задокументовані
- [ ] Моніторинг та alerting налаштовані
- [ ] Документація runbook завершена
- [ ] DR drill успішно проведено
- [ ] Команда навчена процедурам

---

*Версія Документа: 1.0*  
*Класифікація: Внутрішній*  
*Фаза: 9 - Архітектура Даних та Проєктування Бази Даних*  
*Автор: Стефан Костик*

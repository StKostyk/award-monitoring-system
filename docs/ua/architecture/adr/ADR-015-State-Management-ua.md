# ADR-015: Вибір управління станом

**Статус**: Прийнято  
**Дата**: 2025-08-21  
**Автор**: Стефан Костик  
**Зацікавлені сторони**: Архітектор проекту, Frontend команда, Команда розробки

---

## Контекст

Система моніторингу та відстеження нагород потребує надійного рішення управління станом для обробки складного стану додатка, включаючи автентифікацію користувачів, дані нагород, форми та стан UI. Рішення повинно підтримувати корпоративні паттерни, такі як передбачувані оновлення стану, time-travel debugging та тестованість.

### Передумови
- Складний стан додатка через декілька функцій та компонентів
- Потреба в передбачуваних паттернах управління станом
- Оновлення даних в реальному часі з backend API
- Управління станом форм для складних форм подання нагород
- Стан автентифікації та авторизації користувачів

### Припущення
- Redux паттерн забезпечує передбачуване управління станом
- Корпоративні додатки мають користь від централізованого управління станом
- Інструменти розробника для debugging є важливими для продуктивності
- Управління станом повинно добре інтегруватися з Angular сервісами та RxJS

---

## Рішення

**NgRx** було обрано як рішення управління станом для Системи моніторингу та відстеження нагород.

### Обраний підхід
- **Управління станом**: NgRx Store з Redux паттерном
- **Побічні ефекти**: NgRx Effects для обробки асинхронних операцій
- **Управління сутностями**: NgRx Entity для нормалізованого управління станом
- **Інструменти розробника**: NgRx Store DevTools для дебагінгу

### Обґрунтування
- **Redux паттерн**: Передбачуване управління станом з однонаправленим потоком даних
- **Корпоративне управління станом**: Розроблений для великомасштабних Angular додатків
- **Time-Travel Debugging**: Відмінні інструменти розробника для дебагінгу та тестування
- **RxJS інтеграція**: Безшовна інтеграція з RxJS-архітектурою Angular
- **Підтримка спільноти**: Велика спільнота та обширна документація

---

## Наслідки

### Позитивні наслідки
- **Передбачуваний стан**: Незмінні оновлення стану з передбачуваними паттернами
- **Дебагінг**: Можливості time-travel debugging та інспекції стану
- **Тестованість**: Легко тестувати actions, reducers та effects окремо
- **Масштабованість**: Обробляє складне управління станом зі зростанням додатка
- **Досвід розробника**: Відмінний інструментарій та підтримка IDE

### Негативні наслідки
- **Крива навчання**: Redux концепції та NgRx паттерни потребують навчальних інвестицій
- **Шаблонний**: Більш багатослівний ніж просте управління станом на основі сервісів
- **Складність**: Може бути надмірним для простих сценаріїв управління станом

### Нейтральні наслідки
- **Розмір бандлу**: Додає до розміру бандл додатка, але забезпечує значну функціональність
- **Архітектура**: Потребує продуманої архітектури стану та дизайну зберігання

---

## Розглянуті альтернативи

### Альтернатива 1: Akita
- **Переваги**: Менше шаблонного коду, entity-орієнтований підхід, хороша підтримка TypeScript
- **Недоліки**: Менша спільнота, менше корпоративного прийняття
- **Причина відхилення**: NgRx має краще корпоративне прийняття та інструментарій

### Альтернатива 2: NGXS
- **Переваги**: Менше шаблонного коду ніж NgRx, синтаксис на основі декораторів
- **Недоліки**: Менша екосистема, менш зрілий інструментарій
- **Причина відхилення**: NgRx забезпечує кращу довгострокову підтримку та корпоративні функції

### Альтернатива 3: Лише Angular сервіси
- **Переваги**: Простий підхід, відсутність додаткових залежностей
- **Недоліки**: Складне спільне використання стану, відсутність time-travel debugging, складніше тестувати
- **Причина відхилення**: Недостатньо для складного управління станом додатка

---

## Примітки з реалізації

### Технічні вимоги
- **Версія NgRx**: Остання сумісна з Angular 20+
- **Store DevTools**: NgRx Store DevTools для розробки
- **ESLint правила**: NgRx ESLint правила для найкращих практик
- **RxJS**: RxJS оператори для реактивного програмування

### Встановлення та налаштування
```bash
ng add @ngrx/store
ng add @ngrx/effects
ng add @ngrx/entity
ng add @ngrx/store-devtools
ng add @ngrx/eslint-plugin
```

### Структура Store
```typescript
// State Interface
interface AppState {
  auth: AuthState;
  awards: AwardsState;
  users: UsersState;
  ui: UIState;
}

// Feature State приклад
interface AwardsState extends EntityState<Award> {
  loading: boolean;
  error: string | null;
  selectedAwardId: string | null;
  filters: AwardFilters;
}
```

### Паттерни Actions
```typescript
// Award Actions
export const loadAwards = createAction('[Awards Page] Load Awards');

export const loadAwardsSuccess = createAction(
  '[Awards API] Load Awards Success',
  props<{ awards: Award[] }>()
);

export const loadAwardsFailure = createAction(
  '[Awards API] Load Awards Failure',
  props<{ error: string }>()
);
```

### Реалізація Effects
```typescript
@Injectable()
export class AwardsEffects {
  loadAwards$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AwardsActions.loadAwards),
      switchMap(() =>
        this.awardsService.getAwards().pipe(
          map(awards => AwardsActions.loadAwardsSuccess({ awards })),
          catchError(error => of(AwardsActions.loadAwardsFailure({ error })))
        )
      )
    )
  );
}
```

---

## Відповідність та якість

### Вплив на продуктивність
- **Мемоізовані селектори**: Ефективний вибір стану з мемоізацією
- **OnPush стратегія**: Сумісність з OnPush виявленням змін
- **Розбиття бандлу**: Lazy-loaded функція зменшує початковий розмір бандлу

### Супроводжуваність
- **Типобезпека**: Повна підтримка TypeScript з строгою типізацією
- **Тестування**: Комплексні утиліти тестування для actions, reducers та effects
- **Організація коду**: Чітке розділення задач з actions, reducers, effects

### Наслідки для безпеки
- **Незмінний стан**: Запобігає випадковим мутаціям стану
- **Логування actions**: Всі зміни стану відстежуються через actions
- **Серіалізований стан**: Стан може бути серіалізований для дебагінгу та персистентності

---

## Метрики успіху

### Ключові показники ефективності
- **Покриття управління станом**: 90% стану додатка керується через NgRx
- **Продуктивність розробника**: 30% швидший дебагінгу з NgRx DevTools
- **Якість коду**: 100% покриття тестами логіки управління станом

### Моніторинг та сповіщення
- **Продуктивність стану**: Моніторинг продуктивності селекторів та мемоізації
- **Відстеження помилок**: Відстеження помилок, пов'язаних зі станом, через NgRx Effects
- **Розмір бандлу**: Моніторинг впливу NgRx на розмір бандлу додатка

---

## Пов'язані документи

- **Технічний стек**: [Вибір технологічного стеку](../TECH_STACK_ua.md)
- **Інші ADR**: [ADR-013 Frontend Framework](./ADR-013-Frontend-Framework-ua.md)
- **Зовнішні ресурси**: [Документація NgRx](https://ngrx.io/)

---

## Історія версій

| **Дата** | **Автор** | **Зміни** | **Причина** |
|----------|------------|-------------|------------|
| 2025-08-21 | Стефан Костик | Початкова версія | Створення документа |

---

**Статус документа**: Затверджено  
**Дата наступного огляду**: 2026-02-21  
**Категорія ADR**: Технологія 
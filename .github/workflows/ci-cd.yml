# =============================================================================
# Award Monitoring & Tracking System - CI/CD Pipeline
# =============================================================================
# Enterprise-grade pipeline for Java Spring Boot + Angular application
# Supports: Build, Test, Quality Analysis, Security Scan, Docker, Deploy
# =============================================================================

name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
    inputs:
      deploy_environment:
        description: 'Environment to deploy'
        required: false
        default: 'staging'
        type: choice
        options:
          - staging
          - production

env:
  JAVA_VERSION: '21'
  NODE_VERSION: '20'
  REGISTRY: ghcr.io

jobs:
  # ===========================================================================
  # Backend Build & Test
  # ===========================================================================
  backend-build:
    name: Backend Build & Test
    runs-on: ubuntu-latest

    # Service containers for integration tests
    # These provide real PostgreSQL and Redis instances for testing
    services:
      postgres:
        image: postgres:17-alpine
        env:
          POSTGRES_DB: test_db
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    defaults:
      run:
        working-directory: backend

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for SonarQube blame information

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: 'maven'

      - name: Build application
        run: mvn clean compile -B

      - name: Run unit tests
        run: mvn test -B
        env:
          # Even though we have service containers, unit tests shouldn't need them
          # But we set these in case some tests accidentally require them
          SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/test_db
          SPRING_DATASOURCE_USERNAME: test_user
          SPRING_DATASOURCE_PASSWORD: test_password
          SPRING_DATA_REDIS_HOST: localhost
          SPRING_DATA_REDIS_PORT: 6379

      - name: Run integration tests
        run: mvn verify -DskipTests -B
        env:
          # Integration tests run against real databases via service containers
          SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/test_db
          SPRING_DATASOURCE_USERNAME: test_user
          SPRING_DATASOURCE_PASSWORD: test_password
          SPRING_DATA_REDIS_HOST: localhost
          SPRING_DATA_REDIS_PORT: 6379

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: backend-test-results
          path: |
            backend/target/surefire-reports/
            backend/target/failsafe-reports/
          retention-days: 7

      - name: Upload coverage reports
        uses: actions/upload-artifact@v4
        with:
          name: backend-coverage-report
          path: backend/target/site/jacoco/
          retention-days: 7

  # ===========================================================================
  # Frontend Build & Test
  # ===========================================================================
  frontend-build:
    name: Frontend Build & Test
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: frontend

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: npm run lint
        continue-on-error: true  # Don't fail build on lint warnings

      - name: Run unit tests
        # Angular tests need headless mode in CI
        # Make sure package.json has: "test:ci": "ng test --watch=false --browsers=ChromeHeadless --code-coverage"
        run: npm run test -- --watch=false --browsers=ChromeHeadless --code-coverage
        env:
          CI: true

      - name: Build production bundle
        run: npm run build -- --configuration=production

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: frontend-test-results
          path: frontend/coverage/
          retention-days: 7

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: frontend/dist/
          retention-days: 7

  # ===========================================================================
  # Code Quality Analysis
  # ===========================================================================
  code-quality:
    name: Code Quality Analysis
    runs-on: ubuntu-latest
    needs: [backend-build]
    defaults:
      run:
        working-directory: backend

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: 'maven'

      - name: Download coverage reports
        uses: actions/download-artifact@v4
        with:
          name: backend-coverage-report
          path: backend/target/site/jacoco/

      - name: Run code quality checks
        run: mvn verify -DskipTests -B
        continue-on-error: true

      - name: Upload Checkstyle report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: checkstyle-report
          path: backend/target/checkstyle-result.xml
          retention-days: 7

      - name: Upload PMD report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: pmd-report
          path: backend/target/pmd.xml
          retention-days: 7

      - name: Upload SpotBugs report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: spotbugs-report
          path: backend/target/spotbugsXml.xml
          retention-days: 7

      - name: SonarQube analysis
        # Only run SonarQube if the token is configured
        if: ${{ secrets.SONAR_TOKEN != '' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
        run: |
          mvn sonar:sonar -B \
            -Dsonar.projectKey=award-monitoring-system \
            -Dsonar.organization=kostyk-stefan \
            -Dsonar.host.url=${SONAR_HOST_URL} \
            -Dsonar.token=${SONAR_TOKEN} \
            -Dsonar.qualitygate.wait=true

  # ===========================================================================
  # Security Scanning
  # ===========================================================================
  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    needs: [backend-build]
    permissions:
      contents: read
      security-events: write
      actions: read
    defaults:
      run:
        working-directory: backend

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: 'maven'

      - name: OWASP Dependency Check
        run: mvn dependency-check:check -B
        continue-on-error: true
        env:
          NVD_API_KEY: ${{ secrets.NVD_API_KEY }}

      - name: Upload OWASP Dependency Check report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: dependency-check-report
          path: |
            backend/target/dependency-check-report.html
            backend/target/dependency-check-report.json
          retention-days: 30

      - name: Run Trivy vulnerability scanner on filesystem
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: './backend'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Upload Trivy scan results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'
          category: 'trivy-fs-scan'

  # ===========================================================================
  # Docker Build and Push
  # ===========================================================================
  docker-build:
    name: Docker Build and Push
    runs-on: ubuntu-latest
    needs: [backend-build, frontend-build, code-quality]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
    permissions:
      contents: read
      packages: write

    # Output the image tags so other jobs can use them
    outputs:
      backend-image: ${{ steps.backend-meta.outputs.tags }}
      frontend-image: ${{ steps.frontend-meta.outputs.tags }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Convert repository name to lowercase for container registry
      # Container registries require lowercase names
      - name: Prepare image names
        id: prep
        run: |
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          echo "repo=${REPO_LOWER}" >> $GITHUB_OUTPUT
          echo "backend_image=${REGISTRY}/${REPO_LOWER}-backend" >> $GITHUB_OUTPUT
          echo "frontend_image=${REGISTRY}/${REPO_LOWER}-frontend" >> $GITHUB_OUTPUT

      # Generate Docker metadata for backend
      # This creates appropriate tags based on branch, PR, or release
      - name: Extract metadata for backend
        id: backend-meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.prep.outputs.backend_image }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      # Generate Docker metadata for frontend
      - name: Extract metadata for frontend
        id: frontend-meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.prep.outputs.frontend_image }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      # Build and push backend Docker image
      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: ${{ steps.backend-meta.outputs.tags }}
          labels: ${{ steps.backend-meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      # Build and push frontend Docker image
      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: ${{ steps.frontend-meta.outputs.tags }}
          labels: ${{ steps.frontend-meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      # Scan the built images for vulnerabilities
      - name: Run Trivy vulnerability scanner on backend image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.prep.outputs.backend_image }}:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-backend-image.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Upload Trivy backend image scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-backend-image.sarif'
          category: 'trivy-backend-image'

  # ===========================================================================
  # Deploy to Staging
  # ===========================================================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [docker-build, security-scan]
    if: github.event_name == 'push' && github.ref == 'refs/heads/develop'
    environment:
      name: staging
      url: https://staging.awards.example.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # For Kubernetes deployment, you would set up kubectl here
      # This is a placeholder showing the general approach
      - name: Deploy to staging environment
        run: |
          echo "Deploying to staging..."
          echo "Backend image: ${{ needs.docker-build.outputs.backend-image }}"
          echo "Frontend image: ${{ needs.docker-build.outputs.frontend-image }}"

          # Example deployment commands (customize for your infrastructure):
          # kubectl set image deployment/award-backend backend=IMAGE -n staging
          # kubectl set image deployment/award-frontend frontend=IMAGE -n staging
          # kubectl rollout status deployment/award-backend -n staging
          # kubectl rollout status deployment/award-frontend -n staging

          echo "Staging deployment would happen here"
          echo "Configure this based on your infrastructure (K8s, ECS, etc.)"

      - name: Run smoke tests
        run: |
          echo "Running smoke tests against staging..."
          # curl -f https://staging.awards.example.com/actuator/health || exit 1
          echo "Smoke tests would run here"

      - name: Notify deployment
        if: success()
        run: |
          echo "✅ Successfully deployed to staging"
          echo "Consider integrating with Slack/Teams/Discord for notifications"

  # ===========================================================================
  # Deploy to Production
  # ===========================================================================
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [docker-build, security-scan]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://awards.example.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to production environment
        run: |
          echo "Deploying to production..."
          echo "Backend image: ${{ needs.docker-build.outputs.backend-image }}"
          echo "Frontend image: ${{ needs.docker-build.outputs.frontend-image }}"

          # Production deployment with blue-green or canary strategy
          # Example for Kubernetes blue-green:
          # 1. Deploy to green environment
          # 2. Run smoke tests on green
          # 3. Switch traffic to green
          # 4. Monitor for issues
          # 5. Keep blue as rollback option

          echo "Production deployment would happen here"
          echo "Implement blue-green or canary deployment strategy"

      - name: Run production smoke tests
        run: |
          echo "Running smoke tests against production..."
          # Add real smoke test commands here
          # curl -f https://awards.example.com/actuator/health || exit 1
          echo "Production smoke tests would run here"

      - name: Notify deployment success
        if: success()
        run: |
          echo "✅ Successfully deployed to production"
          echo "Version: ${{ github.sha }}"

      - name: Rollback on failure
        if: failure()
        run: |
          echo "❌ Production deployment failed - initiating rollback"
          echo "Implement rollback strategy here"
          # kubectl rollout undo deployment/award-backend -n production
          # kubectl rollout undo deployment/award-frontend -n production
